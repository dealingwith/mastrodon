---
import ThreadGroup from "../components/ThreadGroup.astro";
import type { MastodonPost as MastodonPostType } from "../types/mastodon";
import { processThreads } from "../utils/threadProcessor";
import type { GetStaticPaths, Page } from "astro";
import ChevronLeftIcon from "../components/icons/ChevronLeftIcon.astro";
import ChevronRightIcon from "../components/icons/ChevronRightIcon.astro";
import DocumentIcon from "../components/icons/DocumentIcon.astro";
import { config } from "../config";
import "../assets/app.css";
import { findImageFile } from "../utils/imageUtils";

export const getStaticPaths: GetStaticPaths = async ({ paginate }) => {
  // Filter out replies to other accounts (keep original posts and self-replies)
  function filterOutRepliesToOthers(posts: MastodonPostType[]): MastodonPostType[] {
    // Get the current user's URL from the first post to use for filtering
    const currentUserUrl = posts.length > 0 ? posts[0].account?.url : null;
    
    return posts.filter(post => {
      const inReplyTo = (post as any).inReplyTo;
      const cc = (post as any).cc;
      
      // Include if not a reply
      if (!inReplyTo) {
        return true;
      }
      
      // Check if CC field contains other users (not just Public or current user)
      const hasOtherUsersInCC = cc && Array.isArray(cc) && cc.some((ccItem: string) => {
        // Skip public and non-user URLs
        if (ccItem === 'https://www.w3.org/ns/activitystreams#Public' || !ccItem.includes('/users/')) {
          return false;
        }
        // Skip current user's own URL
        if (currentUserUrl && ccItem === currentUserUrl) {
          return false;
        }
        // This is another user
        return true;
      });
      
      // Filter out replies that involve other users
      if (inReplyTo && hasOtherUsersInCC) {
        return false; // Filter out reply conversations with others
      }
      
      // Keep self-replies and replies without other users in CC
      return true;
    });
  }

  // Load Mastodon archive from JSON file
  async function loadMastodonArchive(): Promise<MastodonPostType[]> {
    let posts: MastodonPostType[] = [];

    try {
      // Import the JSON file directly
      const archiveData = await import("../../data/outbox.json");
      const data = archiveData.default;

      // Handle ActivityPub format
      if (data.orderedItems) {
        posts = data.orderedItems
          .filter(
            (item: any) =>
              item.type === "Create" && item.object && item.object.type === "Note"
          )
          .filter((item: any) => {
            // Skip posts that weren't public (empty cc field)
            const cc = item.cc || item.object?.cc;
            return cc && Array.isArray(cc) && cc.length > 0;
          })
          .map((item: any) => {
            const obj = item.object;

            // Extract numeric ID from URL
            const idMatch = obj.id?.match(/\/statuses\/(\d+)$/);
            const numericId = idMatch ? idMatch[1] : obj.id;

            return {
              id: numericId || Math.random().toString(),
              created_at: obj.published || new Date().toISOString(),
              content: obj.content || "",
              url: obj.url || obj.id,
              visibility: "public",
              sensitive: obj.sensitive || false,
              spoiler_text: obj.summary || "",
              inReplyTo: obj.inReplyTo, // Include the inReplyTo field
              cc: item.cc, // Include the CC field for filtering
              media_attachments:
                obj.attachment?.map((att: any) => ({
                  id: att.id || Math.random().toString(),
                  type: att.mediaType?.includes("image")
                    ? "image"
                    : att.mediaType?.includes("video")
                      ? "video"
                      : att.mediaType?.includes("audio")
                        ? "audio"
                        : "unknown",
                  url: att.url || att.href,
                  preview_url: att.url || att.href,
                  description: att.name || att.summary,
                })) || [],
              account: {
                id: obj.attributedTo || "unknown",
                username: obj.attributedTo?.split("/").pop() || "user",
                display_name: obj.attributedTo?.split("/").pop() || "User",
                avatar: findImageFile("avatar"),
                url: obj.attributedTo || "",
              },
              replies_count: obj.replies?.totalItems || 0,
              reblogs_count: obj.shares?.totalItems || 0,
              favourites_count: obj.likes?.totalItems || 0,
            };
          });
      }

      // Sort by date (newest first)
      posts.sort(
        (a, b) =>
          new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
      );
    } catch (error) {
      console.log("Could not load outbox.json:", error);
    }

    return posts;
  }

  const allPosts = await loadMastodonArchive();
  const posts = config.showRepliesToOthers ? allPosts : filterOutRepliesToOthers(allPosts);
  const threads = processThreads(posts);
  
  // Paginate threads instead of individual posts
  return paginate(threads, { pageSize: 10 });
};

export interface Props {
  page: Page<any>;
}

const { page }: Props = Astro.props;

// Calculate visible page numbers
function getVisiblePages(current: number, total: number) {
  const maxVisible = 5;
  let start = Math.max(1, current - Math.floor(maxVisible / 2));
  let end = Math.min(total, start + maxVisible - 1);
  
  // Adjust start if we're near the end
  if (end - start + 1 < maxVisible) {
    start = Math.max(1, end - maxVisible + 1);
  }
  
  const pages = [];
  
  // Add first page + ellipsis if needed
  if (start > 1) {
    pages.push(1);
    if (start > 2) {
      pages.push('...');
    }
  }
  
  // Add visible page range
  for (let i = start; i <= end; i++) {
    pages.push(i);
  }
  
  // Add ellipsis + last page if needed
  if (end < total) {
    if (end < total - 1) {
      pages.push('...');
    }
    pages.push(total);
  }
  
  return pages;
}

const visiblePages = getVisiblePages(page.currentPage, page.lastPage);
---

<html lang="en" data-theme="cupcake">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>Mastodon Archive{page.currentPage > 1 ? ` - Page ${page.currentPage}` : ""}</title>
  </head>
  <body class="font-sans">
    <header class="relative overflow-hidden">
      <!-- Header background image -->
      <div class="absolute inset-0">
        <img
          src={findImageFile("header")}
          alt="Header background"
          class="w-full h-full object-cover"
        />
      </div>

      <!-- Header content -->
      <div class="relative max-w-2xl mx-auto px-4 py-12 text-center">
        <a href="/" class="inline-block hover:opacity-90 transition-opacity duration-200">
          <h1 class="text-5xl font-bold mb-3 text-shadow-lg text-secondary-content">
            Mastodon Archive
          </h1>
        </a>
        {page.currentPage > 1 && (
          <p class="text-lg mt-2">
            Page {page.currentPage} of {page.lastPage}
          </p>
        )}
      </div>
    </header>

    <main class="max-w-2xl mx-auto px-4 py-12">
      {
        page.data.length === 0 && (
          <div class="rounded-xl shadow-lg p-10 text-center border">
            <div class="w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-6">
              <DocumentIcon class="w-8 h-8" />
            </div>
            <h2 class="text-3xl font-bold mb-6">
              No posts found
            </h2>
            <p class="text-stone-600 mb-6 text-lg">
              Place your Mastodon archive JSON file at{" "}
              <code class="px-3 py-1 rounded-md text-sm font-mono">
                public/outbox.json
              </code>{" "}
              to see your posts here.
            </p>
          </div>
        )
      }

      <div class="space-y-8">
        {page.data.map((thread) => <ThreadGroup thread={thread} />)}
      </div>

      <!-- Pagination Navigation -->
      {page.lastPage > 1 && (
        <nav class="mt-12 flex justify-center items-center space-x-4">
          <!-- Previous Page -->
          {page.url.prev && (
            <a
              href={page.url.prev}
              class="flex items-center space-x-2 px-4 py-2 rounded-lg transition-all duration-200"
            >
              <ChevronLeftIcon />
              <span>Previous</span>
            </a>
          )}

          <!-- Page Numbers -->
          <div class="flex items-center space-x-2">
            {visiblePages.map((pageNum, index) => {
              if (pageNum === '...') {
                return (
                  <span class="px-3 py-2">...</span>
                );
              }
              
              const isCurrentPage = pageNum === page.currentPage;
              return (
                <a
                  href={pageNum === 1 ? "/" : `/${pageNum}`}
                  class={`px-3 py-2 rounded-lg font-medium transition-all duration-200 ${
                    isCurrentPage
                      ? "shadow-md"
                      : "border"
                  }`}
                >
                  {pageNum}
                </a>
              );
            })}
          </div>

          <!-- Next Page -->
          {page.url.next && (
            <a
              href={page.url.next}
              class="flex items-center space-x-2 px-4 py-2 bg-white border rounded-lg transition-all duration-200"
            >
              <span>Next</span>
              <ChevronRightIcon />
            </a>
          )}
        </nav>
      )}
    </main>
  </body>
</html>