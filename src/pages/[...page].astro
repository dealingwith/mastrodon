---
import ThreadGroup from "../components/ThreadGroup.astro";
import type { MastodonPost as MastodonPostType } from "../types/mastodon";
import { processThreads } from "../utils/threadProcessor";
import type { GetStaticPaths, Page } from "astro";
import ChevronLeftIcon from "../components/icons/ChevronLeftIcon.astro";
import ChevronRightIcon from "../components/icons/ChevronRightIcon.astro";
import DocumentIcon from "../components/icons/DocumentIcon.astro";

export const getStaticPaths: GetStaticPaths = async ({ paginate }) => {
  // Filter out replies to other accounts (keep original posts and self-replies)
  function filterOutRepliesToOthers(posts: MastodonPostType[]): MastodonPostType[] {
    return posts.filter(post => {
      const inReplyTo = (post as any).inReplyTo;
      
      // Include if not a reply
      if (!inReplyTo) {
        return true;
      }
      
      // Get the user's attributedTo URL to identify self-replies
      const attributedTo = post.account?.url;
      if (!attributedTo) {
        return true; // Include if we can't determine user
      }
      
      // Extract base URL from attributedTo (e.g., "https://indieweb.social/users/dealingwith")
      const userBase = attributedTo.substring(0, attributedTo.lastIndexOf('/'));
      
      // Include if replying to same user/instance (self-reply for threading)
      if (inReplyTo.startsWith(userBase)) {
        return true;
      }
      
      // Exclude replies to other accounts
      return false;
    });
  }
  // Function to find image file by base name (supports different extensions)
  function findImageFile(baseName: string): string {
    // Define preferred extensions in order of preference
    const extensions = ["jpeg", "jpg", "png", "webp", "gif", "svg"];

    // For now, since you mentioned header is .jpeg, let's set up a simple mapping
    const imageMap: Record<string, string> = {
      header: "jpeg",
      avatar: "jpg", // Update this if your avatar has a different extension
    };

    const extension = imageMap[baseName] || "jpg";
    return `/${baseName}.${extension}`;
  }

  // Load Mastodon archive from JSON file
  async function loadMastodonArchive(): Promise<MastodonPostType[]> {
    let posts: MastodonPostType[] = [];

    try {
      // Import the JSON file directly
      const archiveData = await import("../../public/outbox.json");
      const data = archiveData.default;

      // Handle ActivityPub format
      if (data.orderedItems) {
        posts = data.orderedItems
          .filter(
            (item: any) =>
              item.type === "Create" && item.object && item.object.type === "Note"
          )
          .map((item: any) => {
            const obj = item.object;

            // Extract numeric ID from URL
            const idMatch = obj.id?.match(/\/statuses\/(\d+)$/);
            const numericId = idMatch ? idMatch[1] : obj.id;

            return {
              id: numericId || Math.random().toString(),
              created_at: obj.published || new Date().toISOString(),
              content: obj.content || "",
              url: obj.url || obj.id,
              visibility: "public",
              sensitive: obj.sensitive || false,
              spoiler_text: obj.summary || "",
              inReplyTo: obj.inReplyTo, // Include the inReplyTo field
              media_attachments:
                obj.attachment?.map((att: any) => ({
                  id: att.id || Math.random().toString(),
                  type: att.mediaType?.includes("image")
                    ? "image"
                    : att.mediaType?.includes("video")
                      ? "video"
                      : att.mediaType?.includes("audio")
                        ? "audio"
                        : "unknown",
                  url: att.url || att.href,
                  preview_url: att.url || att.href,
                  description: att.name || att.summary,
                })) || [],
              account: {
                id: obj.attributedTo || "unknown",
                username: obj.attributedTo?.split("/").pop() || "user",
                display_name: obj.attributedTo?.split("/").pop() || "User",
                avatar: findImageFile("avatar"),
                url: obj.attributedTo || "",
              },
              replies_count: obj.replies?.totalItems || 0,
              reblogs_count: obj.shares?.totalItems || 0,
              favourites_count: obj.likes?.totalItems || 0,
            };
          });
      }

      // Sort by date (newest first)
      posts.sort(
        (a, b) =>
          new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
      );
    } catch (error) {
      console.log("Could not load outbox.json:", error);
    }

    return posts;
  }

  const allPosts = await loadMastodonArchive();
  const posts = filterOutRepliesToOthers(allPosts);
  const threads = processThreads(posts);
  
  // Paginate threads instead of individual posts
  return paginate(threads, { pageSize: 10 });
};

// Function to find image file by base name (supports different extensions)
function findImageFile(baseName: string): string {
  // Define preferred extensions in order of preference
  const extensions = ["jpeg", "jpg", "png", "webp", "gif", "svg"];

  // For now, since you mentioned header is .jpeg, let's set up a simple mapping
  const imageMap: Record<string, string> = {
    header: "jpeg",
    avatar: "jpg", // Update this if your avatar has a different extension
  };

  const extension = imageMap[baseName] || "jpg";
  return `/${baseName}.${extension}`;
}

export interface Props {
  page: Page<any>;
}

const { page }: Props = Astro.props;

// Calculate visible page numbers
function getVisiblePages(current: number, total: number) {
  const maxVisible = 5;
  let start = Math.max(1, current - Math.floor(maxVisible / 2));
  let end = Math.min(total, start + maxVisible - 1);
  
  // Adjust start if we're near the end
  if (end - start + 1 < maxVisible) {
    start = Math.max(1, end - maxVisible + 1);
  }
  
  const pages = [];
  
  // Add first page + ellipsis if needed
  if (start > 1) {
    pages.push(1);
    if (start > 2) {
      pages.push('...');
    }
  }
  
  // Add visible page range
  for (let i = start; i <= end; i++) {
    pages.push(i);
  }
  
  // Add ellipsis + last page if needed
  if (end < total) {
    if (end < total - 1) {
      pages.push('...');
    }
    pages.push(total);
  }
  
  return pages;
}

const visiblePages = getVisiblePages(page.currentPage, page.lastPage);
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>Mastodon Archive{page.currentPage > 1 ? ` - Page ${page.currentPage}` : ""}</title>
    <style>
      @import "tailwindcss";
    </style>
  </head>
  <body class="bg-orange-50 text-stone-900 font-sans">
    <header class="relative text-white overflow-hidden">
      <!-- Header background image -->
      <div class="absolute inset-0">
        <img
          src={findImageFile("header")}
          alt="Header background"
          class="w-full h-full object-cover"
        />
      </div>

      <!-- Header content -->
      <div class="relative max-w-2xl mx-auto px-4 py-12 text-center">
        <a href="/" class="inline-block hover:opacity-90 transition-opacity duration-200">
          <h1 class="text-5xl font-bold mb-3 text-shadow-lg">
            My Mastodon Archive
          </h1>
        </a>
        {page.currentPage > 1 && (
          <p class="text-amber-100 text-lg mt-2">
            Page {page.currentPage} of {page.lastPage}
          </p>
        )}
      </div>
    </header>

    <main class="max-w-2xl mx-auto px-4 py-12">
      {
        page.data.length === 0 && (
          <div class="bg-white rounded-xl shadow-lg p-10 text-center border border-orange-200">
            <div class="w-16 h-16 bg-orange-100 rounded-full flex items-center justify-center mx-auto mb-6">
              <DocumentIcon class="w-8 h-8 text-orange-600" />
            </div>
            <h2 class="text-3xl font-bold text-stone-700 mb-6">
              No posts found
            </h2>
            <p class="text-stone-600 mb-6 text-lg">
              Place your Mastodon archive JSON file at{" "}
              <code class="bg-orange-100 px-3 py-1 rounded-md text-sm font-mono text-orange-800">
                public/outbox.json
              </code>{" "}
              to see your posts here.
            </p>
          </div>
        )
      }

      <div class="space-y-8">
        {page.data.map((thread) => <ThreadGroup thread={thread} />)}
      </div>

      <!-- Pagination Navigation -->
      {page.lastPage > 1 && (
        <nav class="mt-12 flex justify-center items-center space-x-4">
          <!-- Previous Page -->
          {page.url.prev && (
            <a
              href={page.url.prev}
              class="flex items-center space-x-2 px-4 py-2 bg-white border border-orange-200 rounded-lg hover:bg-orange-50 hover:border-orange-300 transition-all duration-200 text-stone-700 hover:text-orange-800"
            >
              <ChevronLeftIcon />
              <span>Previous</span>
            </a>
          )}

          <!-- Page Numbers -->
          <div class="flex items-center space-x-2">
            {visiblePages.map((pageNum, index) => {
              if (pageNum === '...') {
                return (
                  <span class="px-3 py-2 text-stone-400">...</span>
                );
              }
              
              const isCurrentPage = pageNum === page.currentPage;
              return (
                <a
                  href={pageNum === 1 ? "/" : `/${pageNum}`}
                  class={`px-3 py-2 rounded-lg font-medium transition-all duration-200 ${
                    isCurrentPage
                      ? "bg-orange-500 text-white shadow-md"
                      : "bg-white border border-orange-200 text-stone-700 hover:bg-orange-50 hover:border-orange-300 hover:text-orange-800"
                  }`}
                >
                  {pageNum}
                </a>
              );
            })}
          </div>

          <!-- Next Page -->
          {page.url.next && (
            <a
              href={page.url.next}
              class="flex items-center space-x-2 px-4 py-2 bg-white border border-orange-200 rounded-lg hover:bg-orange-50 hover:border-orange-300 transition-all duration-200 text-stone-700 hover:text-orange-800"
            >
              <span>Next</span>
              <ChevronRightIcon />
            </a>
          )}
        </nav>
      )}
    </main>
  </body>
</html>